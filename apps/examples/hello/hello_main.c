/****************************************************************************
 *
 * Copyright 2016 Samsung Electronics All Rights Reserved.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied. See the License for the specific
 * language governing permissions and limitations under the License.
 *
 ****************************************************************************/
/****************************************************************************
 * examples/hello/hello_main.c
 *
 *   Copyright (C) 2008, 2011-2012 Gregory Nutt. All rights reserved.
 *   Author: Gregory Nutt <gnutt@nuttx.org>
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 *
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in
 *    the documentation and/or other materials provided with the
 *    distribution.
 * 3. Neither the name NuttX nor the names of its contributors may be
 *    used to endorse or promote products derived from this software
 *    without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 * FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 * COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 * BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
 * OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 * AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
 * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
 * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 *
 ****************************************************************************/

/****************************************************************************
 * Included Files
 ****************************************************************************/

#include <tinyara/config.h>
#include <stdio.h>

#include <fcntl.h>
#include <tinyara/i2c.h>

#include <stdlib.h>
#include <fcntl.h>
#include <errno.h>

/****************************************************************************
 * hello_main
 ****************************************************************************/

#define OLED_I2C_ADDRESS   0x3C

// Control byte
#define OLED_CONTROL_BYTE_CMD_SINGLE    0x80
#define OLED_CONTROL_BYTE_CMD_STREAM    0x00
#define OLED_CONTROL_BYTE_DATA_STREAM   0x40

// Fundamental commands (pg.28)
#define OLED_CMD_SET_CONTRAST           0x81    // follow with 0x7F
#define OLED_CMD_DISPLAY_RAM            0xA4
#define OLED_CMD_DISPLAY_ALLON          0xA5
#define OLED_CMD_DISPLAY_NORMAL         0xA6
#define OLED_CMD_DISPLAY_INVERTED       0xA7
#define OLED_CMD_DISPLAY_OFF            0xAE
#define OLED_CMD_DISPLAY_ON             0xAF

// Addressing Command Table (pg.30)
#define OLED_CMD_SET_MEMORY_ADDR_MODE   0x20    // follow with 0x00 = HORZ mode = Behave like a KS108 graphic LCD
#define OLED_CMD_SET_COLUMN_RANGE       0x21    // can be used only in HORZ/VERT mode - follow with 0x00 and 0x7F = COL127
#define OLED_CMD_SET_PAGE_RANGE         0x22    // can be used only in HORZ/VERT mode - follow with 0x00 and 0x07 = PAGE7

// Hardware Config (pg.31)
#define OLED_CMD_SET_DISPLAY_START_LINE 0x40
#define OLED_CMD_SET_SEGMENT_REMAP      0xA1    
#define OLED_CMD_SET_MUX_RATIO          0xA8    // follow with 0x3F = 64 MUX
#define OLED_CMD_SET_COM_SCAN_MODE      0xC8    
#define OLED_CMD_SET_DISPLAY_OFFSET     0xD3    // follow with 0x00
#define OLED_CMD_SET_COM_PIN_MAP        0xDA    // follow with 0x12
#define OLED_CMD_NOP                    0xE3    // NOP

// Timing and Driving Scheme (pg.32)
#define OLED_CMD_SET_DISPLAY_CLK_DIV    0xD5    // follow with 0x80
#define OLED_CMD_SET_PRECHARGE          0xD9    // follow with 0xF1
#define OLED_CMD_SET_VCOMH_DESELCT      0xDB    // follow with 0x30

// Charge Pump (pg.62)
#define OLED_CMD_SET_CHARGE_PUMP        0x8D    // follow with 0x14

static uint8_t image [] = {
	0xFF, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x81, 0x81, 0xC1, 0xE1, 0xE1, 0xF1, 0xF1, 0xF9, 0xF9, 0xFD, 0xFD, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFD, 0xFD, 0xF9, 0xF1, 0xF1, 0xE1, 0xE1, 0xC1, 0xC1, 0x81, 0x81, 0x01, 0x01, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0xFF, 0x00,
	0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0xFC, 0xFC, 0xFE, 0xFE, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x03, 0x03, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0x7F, 0x3F, 0x1F, 0x0F, 0x87, 0xC3, 0xE3, 0xF3, 0xFB, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xFE,
	0xFC, 0xFC, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00,
	0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x3F, 0x1F, 0x8F, 0x87, 0xC3, 0x81, 0x18,
	0x38, 0x7C, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00,
	0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE,
	0xFC, 0xF0, 0xE1, 0xC3, 0x07, 0x1F, 0x3F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00,
	0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x07, 0x07, 0x0F, 0x0F, 0x1F, 0x1F,
	0x3F, 0x3F, 0x7F, 0x7F, 0xFF, 0xFF, 0xF8, 0xF8, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xF8, 0xF8, 0xF9, 0x7B, 0x7F, 0x3F, 0x1F, 0x1F, 0x0F, 0x0F,
	0x07, 0x07, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00,
	0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x03, 0x03, 0x07, 0x07, 0x0F, 0x0F, 0x1F, 0x1F, 0x1F,
	0x0F, 0x0F, 0x07, 0x03, 0x03, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00,
	0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0xF8, 0x87, 0x40, 0x20, 0xD0, 0x08, 0x04, 0x02, 0x01, 0x00, 0x00, 0xF8, 0x00,
	0x00, 0x00, 0x80, 0x78, 0x00, 0x00, 0xF8, 0x10, 0x08, 0x08, 0x00, 0xC0, 0x30, 0x08, 0x08, 0x08,
	0x08, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xF8, 0x07, 0x00, 0x00, 0xF8, 0x10, 0x08,
	0x08, 0x08, 0xF0, 0x00, 0x00, 0xC0, 0x30, 0x08, 0x08, 0x08, 0x10, 0xF8, 0x07, 0x00, 0x00, 0xF8,
	0x00, 0x00, 0x00, 0x80, 0x78, 0x00, 0x00, 0x00, 0x70, 0x88, 0x88, 0x88, 0x08, 0x30, 0x88, 0x7E,
	0x09, 0x00, 0x00, 0x00, 0xF8, 0x10, 0x08, 0x08, 0x38, 0xC0, 0x00, 0x00, 0x80, 0x40, 0x30, 0x08,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00,
	0xFF, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80,
	0x80, 0x80, 0x8E, 0x81, 0x80, 0x80, 0x80, 0x80, 0x81, 0x86, 0x88, 0x80, 0x80, 0x87, 0x88, 0x88,
	0x88, 0x84, 0x8F, 0x80, 0x80, 0x8F, 0x80, 0x80, 0x80, 0x80, 0x80, 0x87, 0x88, 0x88, 0x88, 0x88,
	0x86, 0x81, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x8E, 0x81, 0x80, 0x80, 0x8F, 0x80, 0x80, 0x80,
	0x80, 0x8F, 0x80, 0x80, 0x80, 0x87, 0x88, 0x88, 0x88, 0x84, 0x8E, 0x81, 0x80, 0x80, 0x87, 0x88,
	0x88, 0x88, 0x84, 0x8F, 0x80, 0x80, 0x80, 0x86, 0x88, 0x88, 0x88, 0x88, 0x87, 0x80, 0x8F, 0x88,
	0x80, 0x80, 0x80, 0x8F, 0x80, 0x80, 0x80, 0xC0, 0xC0, 0xA7, 0x98, 0x86, 0x81, 0x80, 0x80, 0x80,
	0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0xFF, 0x00
};

static struct i2c_dev_s *i2c_dev;
static struct i2c_config_s configs;

#ifdef CONFIG_BUILD_KERNEL
int main(int argc, FAR char *argv[])
#else
int hello_main(int argc, char *argv[])
#endif
{
	int ret = -1;
	uint8_t data[200] = { 0, };

#if 1
	printf("Run i2c1 test! \n");

	int fd;
	char dev_path[16] = { 0, };
	uint32_t frequency = 400000;
	uint8_t address = OLED_I2C_ADDRESS;

	snprintf(dev_path, sizeof(dev_path), "/dev/i2c-%d", 1);
	fd = open(dev_path, O_RDWR);
	if (fd < 0) {
		printf("%s open failed\n", dev_path);
		return -1;
	}

	ret = ioctl(fd, I2C_FREQUENCY, (unsigned long)((uintptr_t)&frequency));
	if (ret < 0) {
		printf("Set fequency failed.\n");
		return -1;
	}

	ret = ioctl(fd, I2C_SLAVE, (unsigned long)((uintptr_t)&address));
	if (ret < 0) {
		printf("Set address failed.\n");
		return -1;
	}

	data[0] = OLED_CONTROL_BYTE_CMD_STREAM;
	data[1] = OLED_CMD_SET_CHARGE_PUMP;
	data[2] = 0x14;
	data[3] = OLED_CMD_SET_SEGMENT_REMAP;
	data[4] = OLED_CMD_SET_COM_SCAN_MODE;
	data[5] = OLED_CMD_DISPLAY_ON;

	ret = write(fd, data, 6);
	if (ret < 0) {
		printf("Sending cmd failed.\n");
		return -1;
	}

	if (argc > 1) {
		for (uint8_t i = 0; i < 4; i++) {

			for (int k = 0; k < 200; k++) {
				data[k] = 0;
			}
			
			data[0] = OLED_CONTROL_BYTE_CMD_SINGLE;
			data[1] = 0xB0 | i;
			data[2] = OLED_CONTROL_BYTE_DATA_STREAM;
			
			ret = write(fd, data, 128 + 3);
			if (ret < 0) {
				printf("i2c_write[%d] fail(%d)\n", i, ret);
			} else printf("i2c_write[%d] Success!!\n", i);
		}
	} else {
		uint8_t *logo = image;
		for (uint8_t i = 0; i < 8; i++) {
			for (int k = 0; k < 200; k++) {
				data[k] = 0;
			}
			
			data[0] = OLED_CONTROL_BYTE_CMD_SINGLE;
			data[1] = 0xB0 | i;
			data[2] = OLED_CONTROL_BYTE_DATA_STREAM;
			
			memcpy(&data[3], logo, 128);
			logo = logo + 128;
			ret = write(fd, data, 128 + 3);
			if (ret < 0) {
				printf("i2c_write[%d] fail(%d)\n", i, ret);
			} else printf("i2c_write[%d] Success!!\n", i);
		}
	}

	close(fd);
	
#else
	printf("Run i2c2 test! \n");

	configs.frequency = 400000;
	configs.address = 0x3C;
	configs.addrlen = 7;

	int port = 1;
	i2c_dev = up_i2cinitialize(port);
	if (i2c_dev == NULL) {
		printf("i2ctest_main: up_i2cinitialize(i2c:%d) failed\n", port);
		return -1;
	}
	
	printf("writing... \n");

	for (int i = 0; i < 200; i++) {
		data[i] = 0;
	}
	
	data[0] = OLED_CONTROL_BYTE_CMD_STREAM;
	data[1] = OLED_CMD_SET_CHARGE_PUMP;
	data[2] = 0x14;
	data[3] = OLED_CMD_SET_SEGMENT_REMAP;
	data[4] = OLED_CMD_SET_COM_SCAN_MODE;
	data[5] = OLED_CMD_DISPLAY_ON;

	ret = i2c_write(i2c_dev, &configs, data, 6);
	if (ret < 0) {
		printf("i2c_write fail(%d)\n", ret);
	} else printf("i2c_write Success!!\n");


	if (argc > 1) {
		for (uint8_t i = 0; i < 4; i++) {

			for (int k = 0; k < 200; k++) {
				data[k] = 0;
			}
			
			data[0] = OLED_CONTROL_BYTE_CMD_SINGLE;
			data[1] = 0xB0 | i;
			data[2] = OLED_CONTROL_BYTE_DATA_STREAM;
			
			ret = i2c_write(i2c_dev, &configs, data, 128 + 3);
			if (ret < 0) {
				printf("i2c_write[%d] fail(%d)\n", i, ret);
			} else printf("i2c_write[%d] Success!!\n", i);
		}
	} else {
		uint8_t *logo = image;
		for (uint8_t i = 0; i < 8; i++) {

			for (int k = 0; k < 200; k++) {
				data[k] = 0;
			}
			
			data[0] = OLED_CONTROL_BYTE_CMD_SINGLE;
			data[1] = 0xB0 | i;
			data[2] = OLED_CONTROL_BYTE_DATA_STREAM;
			
			memcpy(&data[3], logo, 128);
			logo = logo + 128;
			ret = i2c_write(i2c_dev, &configs, data, 128 + 3);
			if (ret < 0) {
				printf("i2c_write[%d] fail(%d)\n", i, ret);
			} else printf("i2c_write[%d] Success!!\n", i);
		}
	}
#endif
	return 0;
}